---
title: WaveSurfer 频谱图加载与绘制流程
tag:
  - tools
date: 2024-08-25
---

## 频谱图如何绘制

这里简单介绍一下频谱图绘制的基本原理，不涉及编程内容

1. 获取音频文件

2. 将音频解析为为 PCM 格式

   > [!tip]
   >
   > PCM是一种将模拟信号转换为数字信号的方法。它通过定期采样音频波形的振幅，并将这些样本量化为离散的数字值来工作。他是一种无损、无压缩的音频格式,保留了原始音频信号的所有信息。
   >
   > 在提到 PCM 和 WAV 这种无损编码格式的时候，注意一些区别：
   >
   > - PCM是一种编码方法，而WAV是一种文件格式。
   > - PCM数据可以存储在多种文件格式中，不仅仅是WAV。
   > - WAV文件可以包含PCM数据，但也可以包含其他类型的音频数据。

3. 将 PCM 编码的文件进行快速傅里叶变换（fft），快速傅里叶变换的时候需要设置傅里叶变换的采样长度

   比如一个 176879 个采样点的音频，设置 `fftSample` 为 512 后，变换后剩下 1378 个时间段，两个相除差不多是 128，刚好是 fftsample 四分之一，之所以不是完全相等，因为为了精确度，可能会设置一个 `noverlap`，进行重叠部分的计算，这里的重叠部分就是四分之三，每次步进四分之一。

4. 因为画布可能不是无限长，所以需要经过重采样的步骤

   比如 1378 个时间段重采样到了 1216（画布的像素长度），如果不重采样，可能会导致画出来的频谱图颜色变淡（也许）

   重采样还是有很多算法的，这个和之前毕设做的插值算法还是有点关系的（毕竟要解决的都是缩放后坐标不匹配的问题），有双线性插值，lanczos 插值等

5. 最后将插值后的矩阵进行上色，这个过程可能会用到一些 colorMap，将强度映射到不同的颜色上，从而绘制出频谱图

## wavesurfer 频谱图具体绘制流程

1. 我们创建插件实例，注册到 `wavesurfer` 实例上，`wavesurfer` 实例会调用插件实例的 `onInit` 函数，这个过程涉及到 `SpectrogramPlugin` 类对 `BasePlugin` 类的 `onInit` 方法的重写

2. 在执行 `onInit` 的过程中，找到用户指定的 `container`（默认和 wavesurfer 实例共用一个 `container`），并且订阅了主波形图的重绘事件，每当其重绘后插件实例也执行 `render` 操作

   虽说是订阅的重绘事件，但波形图第一次绘制也会触发重绘，因为 `wavesurfer` 实例也订阅了他自身的 `renderer` 的 `render` 事件，整个流程如下

   1. `wavesurfer` 实例开始监听事件
   2. `wavesurfer` 为他自身的 `renderer`（渲染器）设置事件
   3. 初始化插件，遍历构造函数传入的选项中的插件实例，调用他们的 `onInit` 方法
   4. 插件实例注册他自身的事件

3. `render` 之前我们要先获取频率数据，这个数据可以在用户指定 opts 的时候传入，但是文档中并没有说明，也许是还在开发中？若没有传入该信息，可以通过调用 `getFrequencies` 方法来获取频率信息，具体的代码如下：

   频率数据是一个三维数组，第一维表示的是通道数；第二维表示时间轴上的采样点，每个元素表示一个时间窗口，这个维度的长度取决于音频长度和窗口的移动步长；第三维表示具体的频率信息，他的长度为 `fftSamples / 2`，每个元素是一个 `0-255` 的值，表示该频率的强度。

   ```ts
   private render() {
     if (this.frequenciesDataUrl) {
       this.loadFrequenciesData(this.frequenciesDataUrl)
     } else {
       const decodedData = this.wavesurfer?.getDecodedData()
       if (decodedData) {
         this.drawSpectrogram(this.getFrequencies(decodedData))
       }
     }
   }
   ```

4. 获取到频率信息后，我们开始最终的绘制频谱图阶段。
