---
title: Predicting Source Code Changes by Mining Change History
tag:
  - paper
  - software engineering
date: 2024-01-12
---

## 摘要

在软件开发的过程中，经常需要根据一个指定的任务来更改不同部分的源代码，而这个过程有一些工具可以用来辅助，这些工具大多是基于代码的静态或者动态分析，而这会遇到一些问题，比如:

- 无法分析依赖于平台的模块
- 无法分析使用不同语言的代码

为了解决这个问题，这篇论文提出了一种方法，使用数据挖掘找到更改模式 (change patterns)，找到过去经常在一起被更改的代码文件，然后在未来的任务中 (我猜想，比如GitHub issue)，推荐出可能相关的代码文件

他们首先将一组代码记为 f~S~，他们的方法最终会提供一组额外的文件，记作 f~R~

这个过程中使用到的算法是: `frequent pattern mining`，这个算法是基于频率数的，相关链接 [频率模式挖掘](https://yzlnew.com/2021/03/frequent-itemset-mining/)

他们评估的大致流程如下:

1. 对 `Eclipse` 和 `Mozilla` 使用本次的成果(工具)来处理，然后考查推荐结果的 `predictability (可预测性)` 和 `interestingness (有趣性)`
1. 其中 `predictability` 是一种量化指标，表示的是开发过程中，推荐的文件和实际更改的文件的重合度
1. `interestingness` 是一种主观指标(我感觉)，他表示用户第一次更改的文件和推荐的文件之间是否有强结构依赖性，没有强依赖性的文件表示有更高的 `interestingness`，因为这些文件很难通过现有的静态分析和动态分析工具来提供

这篇文章的主要贡献如下

- 更改模式挖掘是有效的，这佐证了 `Zimmermann` 的研究成果，虽然说我还没看这篇文章 emmm
- 引入了有趣性的概念，来评估更改模式挖掘的有效性 (ps: 为什么不能是这个算法很好呢，你这个该不会是一篇水文罢)

最后是文章结构

1. 第二章节介绍了 `Eclipse` 和 `Mozilla` 开发历史中的场景，讲了为啥会有这个研究 (也就是研究动机呗)
1. 第三章节主要介绍了他们的方法，也是我最感兴趣的部分
1. 第四章节介绍了他们方法在上述开源项目中的验证
1. 五章节介绍了未解决问题，六章节介绍了相关工作，七章节介绍了结论

## 开发场景

他们使用了两个开源项目来阐释他们的动机，一个是 `Mozilla`，一个用 C++ 编写的浏览器，另一个是 `Eclipse`，一个用 Java 编写的 IDE

### Mozilla

在开发 `Mozilla` 的过程中，他们遇到了这样一个 [bug](https://bugzilla.mozilla.org/show_bug.cgi?id=150339)，当字体过大时，会导致占用内存过高，进而导致 X 服务器崩溃

出现这个问题的原因是，开发人员只对 GTK 部分的代码进行了修改，但是使用 xlib 的部分并没有进行更改，也就是说上次的 patch 只是部分的解决了问题，通过使用本文提到的方法，可以智能的推荐相关的文件，从而避免这种情况

### Eclipse

`Eclipse` 的 [#23587 号 bug](https://bugs.eclipse.org/bugs/show_bug.cgi?id=23587) 是有关 quickfix 的，当用户的方法访问一个不存在的字段的时候，不会自动出现 quickfix，而预期是会出现的

解决这个 bug 需要涉及到 `ASTResolving` 类，而这个类被 45 个其他的类所引用，并且还引用了 93 个其他的类，这导致了复杂的继承结构，使用他们的方法，可以通过共同修改的频率来推荐解决该问题的文件

## 方法

他们的方法分为了三个部分

1. 首先从软件配置管理系统 (SCM) 中提取出数据，并且进行预处理，转换成可以使用数据挖掘算法的格式
1. 然后使用关联规则挖掘算法来找到更改模式
1. 通过搜索更改模式来推荐一个更改任务相关的源代码文件

::: info
之后的文章也许会后面更新，git 诞生的时候已经是 2005 年了，而这篇文章是 2002 年，所以并没有我需要的东西，但是其中提到的算法思路也许可以借鉴一下
:::
