---
title: 执行上下文
tag:
  - javascript
date: 2024-02-27
---

## 什么是执行上下文

JavaScript 引擎在执行代码之间所做的一系列准备（创建的环境），就叫作执行上下文

执行上下文提供了如下的准备

- 变量对象
- 作用域链

::: warning question
这两个名词和`文本环境`和`作用域链`之间有什么关系？
:::

执行上下文存在于一个执行上下文栈中，其中栈顶的上下文被常做为当前上下文，JavaScript 引擎总会在当前上下文中查找所需要的资源。

创建执行上下文的时机有以下四种

1. 全局执行上下文
1. 函数执行上下文
1. eval 函数执行上下文
1. 模块执行上下文

### 全局执行上下文的特殊性

当我们在浏览器环境中，请求一个页面后（并准备执行里面的 JavaScript 代码时），JavaScript 引擎会创建一个全局执行上下文

全局上下文的文本环境由两部分组成，一部分是`全局 scope`，另一部分是`全局对象`，当我们在全局上下文中查找一个变量时，先去全局 scope 中查找，如果没有找到，再去全局对象中查找。

同时，通过 `var` 关键字声明的全局变量和函数会存放在全局对象中，通过 `let` 和 `const` 关键字声明的全局变量会在全局 scope 中。

```javascript
> var a = 3
undefined
> global.a
3
> let b = 4
undefined
> global.b
undefined

> Function
[Function: Function]
> global.Function
[Function: Function]
> let Function = 'some'
undefined
> Function
'some'
> global.Function
[Function: Function]
```

而其他的上下文没有类似的结构，它们的文本环境只有 scope

## 执行上下文创建过程都发生了什么

JavaScript 引擎拿到一份代码的时候，会进行如下步骤

1. 创建执行上下文（根据所处位置创建不同的上下文）
1. 进行词法分析，找到所有的变量和函数声明，其中这个过程也有先后
   1. 首先找到所有的不在函数中的 var 声明
   1. 找到当前块顶级函数声明
   1. 找到当前块 let 和 const 和 class 声明
   1. 找到块中的函数声明（不重复）
1. 进行重复变量名字的处理
1. 进行绑定
   1. var 声明的变量登记并初始化为 undefined
   1. 函数声明登记函数名字，并初始化为一个函数对象
   1. 块中的函数声明登记名字，初始化为 undefined（如果这个名字重复了，就不做任何操作）
   1. let const 和 class 声明的变量登记后不初始化
1. 开始执行代码

以一份代码为例

```javascript
var a = 3
function foo() {
    console.log(a)
    let a = 3
}
foo()
```

首先创建全局执行上下文，然后找到了一个全局变量 `a` 和一个全局函数 `foo`，然后进行绑定，开始执行代码，执行到第一行时，a 被赋值为了 3

然后开始执行 `foo` 函数，创建了一个函数执行上下文，此时继续进行词法分析，找到了一个 `a` 的声明，然后进行绑定，但注意此时的 `a` 并没有被初始化，所以在执行 `console.log(a)` 时会报错，这就是暂时性死区的原因

::: tip
在词法分析中找到的顶级函数声明会创建一个函数对象，这个函数对象体内会保存创建时执行上下文的文本环境，然后当我们创建一个函数执行上下文的时候，其文本环境会以保存的执行上下文为父，形成一条链
:::

## 作用域

作用域就是执行上下文的文本环境（或者说词法环境），他们这三个名词可以认为是等价的

`函数的作用域在函数创建的时候就已经决定，而不是调用时候决定的` 这句话也可以通过上述内容来理解，因为在执行代码之前，函数创建的时候就已经创建了函数对象，而函数对象内部保存了创建时的执行上下文的文本环境

<img width='' src='https://raw.githubusercontent.com/shellRaining/img/main/2402/lexical_scope.png'>

### 块作用域

块作用域就是大括号中间的作用域，（全局上下文中的全局 scope 也可以看作是一个块作用域），块作用域可以看作是对执行上下文环境的补充（我自己认为的）

1. 在创建上下文等一系列操作执行完之后，JavaScript 开始执行代码，当执行到一个块时，会在当前上下文的文本环境中补充一个记录环境，链接在当前上下文文本环境的前面
1. 然后进行词法分析，找到块中所有顶级的函数声明，还有块中剩余的 let const class（不找 var 是因为在上下文的解析过程中已经全部找完了）
1. 进行重复处理
1. 进行绑定，登记函数名字，给其初始化一个函数对象，登记变量名字，不初始化 （注意，这里的登记位置都是新的记录环境）

::: warning
这里新建的函数对象内部也有一个文本环境，指向的是块作用域进入时创建的环境记录，当退出这个块作用域时，他的指向会更改为上面的环境记录（或者文本环境），并且也会在全局执行上下文的全局对象中查找是否有同名，如果有则赋值给他，没有就不做任何操作。

你问我为什么去全局上下文的全局对象找，因为这是按顺序的，如果既不在全局上下文，也不在全局上下文的块作用域中，那不就剩下一个函数执行上下文中没有分析了嘛，但是那涉及到闭包，我们稍后分析
:::

这边给一个例子

```javascript
console.log(foo);

if (true) {
  function foo() {
    console.log('this is foo');
  }
}

foo()
```

按照我们所说的，首先创建全局上下文，找到了块作用域中的函数 `foo`，然后绑定到 `undefined`，开始执行代码，执行到 `console.log(foo)` 时，输出 `undefined`

然后执行块作用域中代码，首先创建环境记录，然后找到顶级函数 `foo`，为其绑定到一个函数对象，执行后销毁环境记录，此时发现全局对象中已经有了同名的 `foo`，所以发生了赋值，因此再执行 `foo()` 的时候就可以找到需要的函数对象了

而我们如果将 true 换为 false，就会报错，因为块作用域代码并没有执行，所以全局对象中只有一个 `foo`，其值为最开始的 `undefined`

再看一个例子

```javascript
let foo;

if (true) {
  function foo() {
    console.log('this is foo');
  }
}

foo()
```

分析同上，最开始全局上下文声明的 `foo` 被放入了全局 scope 中，然后执行块作用域中的代码，找到了顶级函数 `foo`，为其绑定了一个函数对象，退出时销毁环境记录，发现全局对象中没有 `foo` 的名字（因为一开始 foo 声明后被绑定在了全局 scope 中），之后执行 `foo()` 时候自然会报错

而我们如果将 let 换为 var，这个报错就不会出现，具体情况自己分析

:::tip
上面这种情况 LSP 静态检查也会报错 `Cannot redeclare block-scoped variable 'foo'`，所以不用担心自己写的代码出现这种情况
:::

### for 循环中的块作用域

首先看这个代码

```javascript
const list = [];

for (var i = 0; i < 3; i++) {
  list[i] = function () {
    console.log(i);
  };
}

list.forEach((fn) => fn());
```

这个代码会打印出三个 3，而不是 0 1 2，原因如下

1. 最开始创建全局上下文将 list 和 i 绑定到全局上下文的词法环境中
1. 然后执行 for 语句小括号的代码，即给 i 赋值操作，检查循环条件，然后进入到大括号中的代码执行（此时创建了环境记录，实际上没有可以记录的变量名），为 list 的值进行赋值操作（这里是函数表达式）
1. 执行完循环代码后，开始执行 list 中所有的函数，逐个创建函数上下文，他们的词法环境都是以函数内部保存的环境记录为父（销毁后重新指向了全局上下文的文本环境），因为他们自己的文本环境中并没有 i，因此向上查找，发现此时的 i 已经变成了 3，因此全部打印 3

图示如下

<img width='' src='https://raw.githubusercontent.com/shellRaining/img/main/2402/for_stm_var.png'>

而与此同时，如果把 for 中的 var 改成 let，会有些许改变

1. 最开始创建全局上下文将 list 绑定到全局上下文的词法环境中
1. 然后执行 for 语句小括号的代码，首先创建一个环境记录，将 i 记录，然后复制该环境记录，用以进行循环条件判断操作，等进入块作用域后，创建新的环境记录，连接到上面刚创建的环境记录前面，此时创建的函数对象的文本环境就是这个最新的环境记录。等到开始下一轮循环的时候，会再次复制环境记录，对里面的 i 进行运算赋值操作，然后判断是否符合循环条件，然后执行块作用域代码，如此循环
1. 执行完循环代码后，开始执行 list 中所有的函数，逐个创建函数上下文，他们的词法环境都是以函数内部保存的环境记录为父（销毁后指向了他们前面的环境记录），因为他们自己的文本环境中并没有 i，因此向上查找，发现环境记录中有已经复制保存后的 i（即对应的 0 1 2），所以可以打印出相应的值

图示如下

<img width='' src='https://raw.githubusercontent.com/shellRaining/img/main/2402/for_stm_let.png'>

同理可以知道这个代码是不会因为重复使用 let 定义 i 报错的

```javascript
for (let i = 0; i < 3; i++) {
  let i = 10;
  console.log(i);
}
```

因为 for 创建的 i 的环境记录和块作用域中创建的 i 的环境记录根本不是同一个

## 参考

[https://www.bilibili.com/video/BV1wD4y1D7Pp](https://www.bilibili.com/video/BV1wD4y1D7Pp)
