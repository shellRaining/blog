---
title: V8 的垃圾回收机制
tag:
  - browser
  - interview_question
date: 2024-03-25
---

## V8 的垃圾回收模型

V8 引擎中的内存使用也并不是无限制的。具体来说，默认情况下，V8 引擎在 64 位系统下最多只能使用约 `1.4GB` 的内存，在 32 位系统下最多只能使用约 `0.7GB` 的内存，在这样的限制下，必然会导致在 node 中无法直接操作大内存对象，比如将一个 2GB 大小的文件全部读入内存进行字符串分析处理

V8 的垃圾回收策略主要是基于分代式垃圾回收机制，其根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。

V8 的内存结构主要由以下几个部分组成：

- `新生代(new_space)`：大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。
- `老生代(old_space)`：新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为老生代指针区和老生代数据区，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。
- `大对象区(large_object_space)`：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区。
- `代码区(code_space)`：代码对象，会被分配在这里，唯一拥有执行权限的内存区域。

## V8 的垃圾回收算法

### 新生代

在 V8 引擎的内存结构中，新生代主要用于存放存活时间较短的对象。新生代内存是由两个 `semispace`（半空间）构成的，内存最大值在 64 位系统和 32 位系统上分别为 `32MB` 和 `16MB`，在新生代的垃圾回收过程中主要采用了 `Scavenge` 算法。

`Scavenge` 算法是一种典型的牺牲空间换取时间的算法，对于老生代内存来说，可能会存储大量对象，如果在老生代中使用这种算法，势必会造成内存资源的浪费，但是在新生代内存中，大部分对象的生命周期较短，在时间效率上表现可观，所以还是比较适合这种算法。

它将新生代内存一分为二，每一个部分的空间称为 `semispace`，其中处于激活状态的区域我们称为 `From` 空间，未激活(inactive new space)的区域我们称为 `To` 空间。这两个空间中，始终只有一个处于使用状态，另一个处于闲置状态。我们的程序中声明的对象首先会被分配到 `From` 空间，当进行垃圾回收时，如果 `From` 空间中尚有存活对象，则会被复制到 `To` 空间进行保存，非存活的对象会被自动回收。当复制完成后，`From` 空间和 `To` 空间完成一次角色互换，`To` 空间会变为新的 `From` 空间，原来的 `From` 空间则变为 `To` 空间。

### 晋升

当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中，这种对象从新生代转移到老生代的过程我们称之为晋升。
对象晋升的条件主要有以下两个：

- 对象是否经历过一次 `Scavenge` 算法
- `To` 空间的内存占比是否已经超过 `25%`

### 老生代

在老生代中，因为管理着大量的存活对象，如果依旧使用 Scavenge 算法的话，很明显会浪费一半的内存，因此已经不再使用 Scavenge 算法，而是采用新的算法 Mark-Sweep（标记清除）和 Mark-Compact（标记整理）来进行管理。

在早前我们可能听说过一种算法叫做引用计数，该算法的原理比较简单，就是看对象是否还有其他引用指向它，如果没有指向该对象的引用，则该对象会被视为垃圾并被垃圾回收器回收。但是这种算法有一个很明显的缺点，就是无法处理循环引用的情况，比如对象 A 引用了对象 B，对象 B 又引用了对象 A，这样的话，这两个对象的引用计数永远不会为 0，导致这两个对象永远无法被回收。

因此为了避免循环引用导致的内存泄漏问题，截至 2012 年所有的现代浏览器均放弃了这种算法，转而采用新的 `Mark-Sweep（标记清除）` 和 `Mark-Compact（标记整理）` 算法。在上面循环引用的例子中，因为变量 a 和变量 b 无法从 window 全局对象访问到，因此无法对其进行标记，所以最终会被回收

`Mark-Sweep（标记清除）`分为标记和清除两个阶段，在标记阶段会遍历堆中的所有对象，然后标记活着的对象，在清除阶段中，会将死亡的对象进行清除。Mark-Sweep 算法主要是通过判断某个对象是否可以被访问到，从而知道该对象是否应该被回收，但是这种算法会导致内存碎片的产生，因为清除后会产生很多不连续的内存空间。

`Mark-Compact（标记整理）`算法是在标记清除的基础上进行了优化，它会在清除阶段中，将存活的对象向一端移动，然后直接清理掉边界外的内存，这样就可以减少内存碎片的产生。

在这之后还引入了增量标记算法，因为在进行垃圾回收的时候，会阻塞 JavaScript 的执行，导致页面卡顿，为了解决这个问题，V8 引入了增量标记算法，将标记过程分为多个小步骤，每执行完一个小步骤就让 JavaScript 执行一会儿，这样就可以让垃圾回收和 JavaScript 执行交替进行，减少页面卡顿的情况。
