---
title: TypeScript 中的类型
tag:
  - book
  - typescript
date: 2024-07-04
---

## 类型基础

### 基础类型

TypeScript 中的基础类型是在 JavaScript 基础上进行拓展的，包含了三个新的类型

1. `void` 表示一个值不存在，用于函数的返回值

1. `enum` 枚举类型分为三类，字符型，数字型，异构型，他们都会被编译成对象，使用方法如下

   ```typescript
   enum Foo {
   	A = 1,
   	B = 2,
   	C = '3'
   }
   const num: Foo = Foo.A
   ```

   其中 `Foo` 被称作联合枚举类型，他的字段 `Foo.A` 被称作联合枚举成员类型

1. `字面量` 字面量类型都只有一个可能的值，即字面量本身，比如 `true`， `'hello'`

______________________________________________________________________

这里补充一下单例类型（单元类型），因为仅包含一个可能的值，因此被称作单例类型，比如 `undefined`，`void`，`null`，`字面量` 等，实际上这个是另一个维度的分类，因此可能和上面有重叠。

### 顶端（尾端）类型

顶端类型是所有类型的父类型，在 TypeScript 中包含两种顶端类型

#### `any`

因为是所有类型的父类型，因此可以将任意类型的变量赋值给一个 `any` 类型的变量，同时 `any` 类型变量也可以赋值给任意类型的其他变量（包含他自身），因此可以合理的利用这个类型来跳过类型检查。

同时，如果一个变量无法推导出类型，默认也会变成 `any` 类型。为了避免滥用，可以适当调整编译选项，具体见 [TypeScript 编译配置](./config)

#### `unknown`

这是更安全的一种顶端类型，我们可以将任意类型赋值给 `unknown` 类型变量（与 `any` 相同），但是只能将 `unknown` 赋值给 `any` 和他自身。

在执行一些算术操作时候，也必须要先细化类型，否则会爆出编译错误。

______________________________________________________________________

尾端类型是其他所有类型的子类型，因此尾端类型不存在一个值来表示即使是 `any` 类型也无法给他赋值，他只是一个概念上的东西。TypeScript 中仅有一个尾端类型 `never`。

`never`

尾端类型主要在函数返回值上发光发热，他表示函数不可能返回值，这和 `void` 有区别，前者意思为函数不可能结束（由于异常，或者死循环），后者表示函数可以执行完，但是没有返回值。

还有一个地方也会用到 `never`，就是类型体操……有一些工具类型会用到它，比如 `Exclude<T, U> = T extends U ? never : T`

### 数组类型

主要是有两种声明方式，简单类型的数组可以直接通过方括号来定义，比较复杂的数组类型倾向于使用泛型来定义。

这里还涉及只读类型数组的定义，有三种方法：

1. 使用 `ReadonlyArray<T>` 来定义

1. 使用 `readonly` 修饰符

1. 使用 `Readonly<T>` 工具类型来定义，这个工具类型定义如下：

   ```typescript
   type Readonly<T> = {
   	readonly [K in keyof T]: T[K];
   }
   ```

   他只可以用用在对象身上，因此定义一个只读数组的代码如下 `Readonly<number[]>`

### 元组类型

元组是由有限个元素组成的有序列表，一个简单定义（经典元组）如下：

```typescript
const point: [number, number] = [0, 0]
```

我们还可以使用问号来表示可选元素（和 JavaScript 一样），或者使用剩余元素语法：

```typescript
const tuple: [number, ...string[]];
const point: [number, number, number?];
```

在获取一个元组类型的对象的长度时，TypeScript 编译器会尽可能的利用元组的定义信息来推断长度，比如上面的 `point` 的长度的类型就是一个字面量的联合类型 `2|3`。

同时注意，元组类型是数组类型的子类型，因此可以赋值给数组类型，反之不可以
